*** 1variables1
Create a variable and assign it a value.

# Ruby uses the snake_case convention for variable names instead of the camelCase convention like other languages.
first_name = "Tyler"





*** 2interpolation1
Show how to use string interpolation and concatenation. 

# Strings can be in single or double quotes but note that interpolation will only work with double quotes. 

# String interpolation
name = "Tyler"
greeting = "Hello, #{name}, it is good to see you."

# String concatenation
new_name = "Bill"
new_greeting = "Hello, " + new_name + ", it is good to see you."





*** 3methods1
Create a method and then invoke it.

def say_hello
    puts "Hello!"
end

say_hello





*** 4methods2
Create a method that takes parameters and then invoke it. 

def greeting(name, time_of_day)
    puts "Hello #{name}, it is a beautiful #{time_of_day}."
end

greeting("Dan", "morning")





*** 5methods3
Create a method with default arguments and then invoke it once while supplying arguments and once without supplying any arguments. 

def programmer_greeting(name="friend", language="JavaScript")
    puts "Hello #{name}, I heard you are a great #{language} programmer."
end

programmer_greeting("Sarah", "Python")
programmer_greeting





*** 6printing1
Show how to print multiple items both on the same line and then printed out on separate lines. 

item1 = "First thing to print."
item2 = "Second thing to print."
item3 = "Third thing to print."

print item1
print item2
print item3

puts

puts item1
puts item2
puts item3





*** 7return1
Show what a method will return by default and what it will return when the 'return' keyword is used. 

def names
    person1 = "John"
    person2 = "Bill"
    person3 = "Jessica"
end

# A method will return the value of the last statement by default. This example will return person3 with a value of 'Jessica'.
puts names


def names2
    person1 = "John"
    return person2 = "Bill"
    person3 = "Jessica"
end

# The return keyword will interupt the execution of the method and return the value of that line. This example will return person2 with a value of 'Bill'.
puts names2





*** 8pry1
Show how to use the pry gem for debugging.

# After requiring the pry gem, you can add binding.pry in your code to stop the code execution and open a new REPL. You can look at the value of variables and update the values. Type 'exit' to close. 

require 'pry'

def pry_testing
    thing1 = "This is the first variable"
    thing2 = 7
    thing3 = "Washington"
    binding.pry
end

pry_testing





*** 9scope1
Create a method and declare some variables both inside and outside the method. Show how scope determines which variables can be accessed from different locations in the program. 

var1 = "Ted"
var2 = "Bill"

def scope_method
    var3 = "Dawn"
    var4 = "Jill"

    # var2 will not print because it was definied outside the method but is being called inside the method. 
    puts var2

    #var4 will print becuase it was defined inside a method and is being called inside the method. 
    puts var4
end

scope_method

# var1 will print becuase it was definied outside a method and is also being called outside a method.
puts var1 

# var3 will not print because it was defined inside a method but is being called outside that method.
puts var3 





*** 10truthy1
Show how to use the bang operator (!) to determine if something is truthy or falsey. 

# variable is assigned a string with a value of "hello". This is considered truthy. Using a single ! operator will return to oppsite of this which will be false. 
# Using the ! operator twice will take the opposite again and return true. 

# Note in Ruby only false and nil are considered falsey values. Everything else is truthy, even 0 and an empty string ''. 

variable = "hello"

puts variable
puts !variable
puts !!variable





*** 11boolean1
Show how to use the And and Or boolean operators. 

# For the And operator, both expressions must evaluate to true in order to return true.
puts true && true
puts true && false

# For the Or operator, only one expression must evaluate to true in order to return true. 
puts false || true
puts false || false





*** 12boolean1
Show how to use the comparison operators. 

puts "yellow" == "yellow"
puts "yellow" != "yellow"

puts 7 > 3
puts 7 < 3
puts 10 >= 10
puts 10 <= 10





*** 13conditional1
Write an if statement. 

dog = "tired"

if dog == "hungry"
    puts "Feed the dog."
elsif dog == "bored"
    puts "Walk the dog."
elsif dog == "tired"
    puts "Let the dog sleep."
else
    puts "The dog is fine."
end





*** 14conditional2
Write a case statement.

current_weather = "raining"

case current_weather
  when "sunny"
    puts "grab some sunscreen!"
  when "raining"
    puts "grab an umbrella"
  when "snowing"
    puts "bundle up"
end 





*** 15looping1
Write a loop that runs 10 times. Show how you can also do this without a counter using the times method. 

counter = 0

loop do 
    counter = counter + 1

    puts "The loop has run #{counter} times."

    if counter >= 10
        break
    end
end


# The times method must be called on an integer and will tell your loop to run a specific number of times. 
10.times do
    puts "Run this loop 10 times without a counter"
end





*** 16looping2
Write both a while loop and an until loop that runs 10 times. 

counter1 = 0
while counter1 < 10
    puts "This is the while loop"
    counter1 += 1
end


counter2 = 0
until counter2 == 10
    puts "This is the until loop"
    counter2 += 1
end





*** 17arrays1
Create an array of items. Show how to add new items both at the end of the array and at the beginning of the array. 

fruits = ["banana", "strawberry", "watermelon"]

# Both the shovel operator (<<) and the push method can be used to add items
# to the end of an array. 
fruits << "apple"
fruits.push("peach")

# The unshift method will add an item to the beginning of the array. 
fruits.unshift("grape")





*** 18arrays2
Create an array of items. Show how to remove items from both the end and the beginning of the array. 

fruits = ["peach", "apple", "banana", "strawberry", "watermelon"]

# The pop method will remove the last item from the array.
fruits.pop

# The shift method will remove the first item from the array. 
fruits.shift





*** 19arrays3
Create an array of items. Show how to access some of the different items in the array and how to look up the index of a specific item. 

fruits = ["peach", "apple", "banana", "strawberry", "watermelon"]

puts fruits[1]

# Putting a negative index number will start at the end of the array and work backwards. 
puts fruits[-2]

# The first and last methods can be used to find the first and last items in an array. 
puts fruits.first
puts fruits.last

# The index method will return the index number of the first item that matches the given argument. 
puts fruits.index("banana")





*** 20arrays4
Create an array of numbers. Show how to use methods to sort the array, reverse the array, show if a specific number is included in the array, and show the size of the array. 

numbers = [4, 8, 3, 5, 9]

# This will not modify the original array, use the sort! method instead if you want to modify the original. 
print numbers.sort
puts

# This will not modify the original array, use the reverse! method instead if you want to modify the original. 
print numbers.reverse
puts

puts numbers.include?(8)

puts numbers.size





*** 21iteration1
Show how to use the each method and the map/collect method to iterate through an array. 

# The each method will iterate through an array but note that the return value will always be the original array. 
primary_colors = ["Red", "Yellow", "Blue"]
updated_primary_colors = primary_colors.each do |color|
  puts "Primary Color #{color} is #{color.length} letters long."
end 
puts updated_primary_colors



# The map or collect method (they both do the same thing) will iterate through an array but it will modify the array. 
toppings = ["pickles", "mushrooms", "bacon"]
updated_toppings = toppings.map do |topping|
    "I love #{topping} on my burgers!"
end
puts updated_toppings





*** 22iteration2
Show how to use the all, none, any, and include boolean methods on an array. 

numbers = [1, 3, 4]

all_under_seven = numbers.all? do |number|
    number < 7
end
puts all_under_seven


none_equal_five = numbers.none? do |number|
    number == 5
end
puts none_equal_five


any_greater_than_four = numbers.any? do |number|
    number > 4
end
puts any_greater_than_four


puts numbers.include?(3)





*** 23iteration3
Show how to use the select, detect/find, and reject methods on an array. 

numbers = [1,2,3,4,5]

# The select method will return a new array with the elements that caused the block to return true. 
new_numbers1 = numbers.select do |number|
    number.even?
end
print new_numbers1
puts

# The detect or find method (they both do the same thing) will return the first element that makes the 
# block evaluate to true. 
new_numbers2 = numbers.find do |number|
    number > 3
end
print new_numbers2
puts

# The reject method will return a new array with the elements that caused the block to return false. 
new_numbers3 = numbers.reject do |number|
    number.even?
end
print new_numbers3
puts





*** 24iteration4
Show how to sort an array. 

items = ["ball", "dog", "apple", "elephant", "cat"]
print items.sort
puts





*** 25hashes1
Create a hash using string keys, symbol keys, and using JSON style. Retrieve a value from each one. 

# Keys are strings
hash1 = {
    "item1" => "milk",
    "item2" => "bread",
    "item3" => "eggs"
}
puts hash1["item1"]

# Keys are symbols
hash2 = {
    :item1 => "milk",
    :item2 => "bread",
    :item3 => "eggs"
}
puts hash2[:item2]

# JSON style. Note the keys here are still symbols. 
hash3 = {
    item1: "milk",
    item2: "bread",
    item3: "eggs"
}
puts hash3[:item3]





*** 26hashes2
Create a hash and check if a specific key exists. Print one message if it does and another if it does not. 

list = {
    item1: "milk",
    item2: "eggs"
}

# If a hash key is not found, it will return nil which is falsey. 
if list[:item2]
    puts "Eggs are on the list."
else
    puts "Missing."
end





*** 27hashes3
Create a hash. Then update the value of one of the keys and also create a new key with a value. 

list = {
    item1: "milk",
    item2: "eggs"
}

list[:item2] = "cheese"

list[:item3] = "bread"





*** 28hashes4
Show that you can create and manipulate nested data structures. 

# Array of arrays
outer_array1 = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
# This will print 7
puts outer_array1[2][0]


# Array of hashes
outer_array2 = [
    {num1: 1, num2: 2, num3: 3},
    {num1: 4, num2: 5, num3: 6},
    {num1: 7, num2: 8, num3: 9}
]
# This will print 5
puts outer_array2[1][:num2]


# Hash of arrays
outer_hash1 = {
    array1: [1, 2, 3],
    array2: [4, 5, 6], 
    array3: [7, 8, 9]
}
# This will print out 6
puts outer_hash1[:array2][2]


# Hash of hashes
outer_hash2 = {
    hash1: {num1: 1, num2: 2, num3: 3},
    hash2: {num1: 4, num2: 5, num3: 6},
    hash3: {num1: 7, num2: 8, num3: 9}
}
# This will print out 2
puts outer_hash2[:hash1][:num2]
